# GitLab CI/CD Pipeline for Spring Boot Product API
image: maven:3.9.5-openjdk-17

variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  MAVEN_CLI_OPTS: "--batch-mode --errors --fail-at-end --show-version"
  POSTGRES_DB: productdb_test
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  POSTGRES_HOST_AUTH_METHOD: trust

# Cache Maven dependencies
cache:
  paths:
    - .m2/repository/
    - target/

stages:
  - validate
  - test
  - build
  - package
  - deploy

# Validate stage - Check project structure and dependencies
validate:
  stage: validate
  script:
    - mvn $MAVEN_CLI_OPTS validate
    - mvn $MAVEN_CLI_OPTS dependency:resolve
  artifacts:
    reports:
      junit: target/surefire-reports/TEST-*.xml
    expire_in: 1 hour

# Test stage - Run unit and integration tests
test:
  stage: test
  services:
    - postgres:15
  variables:
    SPRING_PROFILES_ACTIVE: test
    SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/$POSTGRES_DB
    SPRING_DATASOURCE_USERNAME: $POSTGRES_USER
    SPRING_DATASOURCE_PASSWORD: $POSTGRES_PASSWORD
  before_script:
    - apt-get update -qq && apt-get install -y -qq postgresql-client
    - export PGPASSWORD=$POSTGRES_PASSWORD
    - psql -h postgres -U $POSTGRES_USER -d postgres -c "CREATE DATABASE $POSTGRES_DB;"
  script:
    - mvn $MAVEN_CLI_OPTS clean test
    - mvn $MAVEN_CLI_OPTS jacoco:report
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    reports:
      junit: target/surefire-reports/TEST-*.xml
      coverage_report:
        coverage_format: jacoco
        path: target/site/jacoco/jacoco.xml
    paths:
      - target/site/jacoco/
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

# Build stage - Compile and package the application
build:
  stage: build
  script:
    - mvn $MAVEN_CLI_OPTS clean compile
  artifacts:
    paths:
      - target/classes/
    expire_in: 1 hour

# Package stage - Create JAR file
package:
  stage: package
  script:
    - mvn $MAVEN_CLI_OPTS clean package -DskipTests
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 week
  only:
    - main
    - develop
    - tags

# Code Quality Analysis with SonarQube (optional)
code_quality:
  stage: test
  image: maven:3.9.5-openjdk-17
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - mvn $MAVEN_CLI_OPTS clean verify sonar:sonar -Dsonar.projectKey=$CI_PROJECT_NAME -Dsonar.host.url=$SONAR_HOST_URL -Dsonar.login=$SONAR_TOKEN
  allow_failure: true
  only:
    - merge_requests
    - main
    - develop
  when: manual

# Security Scan
security_scan:
  stage: test
  script:
    - mvn $MAVEN_CLI_OPTS org.owasp:dependency-check-maven:check
  artifacts:
    reports:
      dependency_scanning: target/dependency-check-report.json
    paths:
      - target/dependency-check-report.html
    expire_in: 1 week
  allow_failure: true
  only:
    - main
    - develop

# Docker Build and Push
docker_build:
  stage: package
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
    LATEST_TAG: $CI_REGISTRY_IMAGE:latest
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
    - |
      if [ "$CI_COMMIT_REF_NAME" == "main" ]; then
        docker tag $IMAGE_TAG $LATEST_TAG
        docker push $LATEST_TAG
      fi
  dependencies:
    - package
  only:
    - main
    - develop
    - tags

# Deploy to Development Environment
deploy_dev:
  stage: deploy
  image: alpine:latest
  variables:
    ENVIRONMENT: "development"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to development environment..."
    - echo "Application URL will be available at $DEV_APP_URL"
    # Add your deployment script here
    # Example: kubectl apply -f k8s/dev/ or docker-compose up -d
  environment:
    name: development
    url: $DEV_APP_URL
  dependencies:
    - docker_build
  only:
    - develop
  when: manual

# Deploy to Staging Environment
deploy_staging:
  stage: deploy
  image: alpine:latest
  variables:
    ENVIRONMENT: "staging"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging environment..."
    - echo "Application URL will be available at $STAGING_APP_URL"
    # Add your deployment script here
  environment:
    name: staging
    url: $STAGING_APP_URL
  dependencies:
    - docker_build
  only:
    - main
  when: manual

# Deploy to Production Environment
deploy_production:
  stage: deploy
  image: alpine:latest
  variables:
    ENVIRONMENT: "production"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to production environment..."
    - echo "Application URL will be available at $PROD_APP_URL"
    # Add your deployment script here
  environment:
    name: production
    url: $PROD_APP_URL
  dependencies:
    - docker_build
  only:
    - tags
  when: manual

# Cleanup job - Remove old artifacts
cleanup:
  stage: deploy
  script:
    - echo "Cleaning up old artifacts..."
    - find target -name "*.jar" -mtime +7 -delete || true
  when: always
  allow_failure: true